## 动态规划

### 介绍

动态规划是运筹学的一个分支，是求解决策过程最优化的过程。英文名称：Dynamic Programming 简称：DP 。

简单来说：他是解决多阶段决策过程最优化的一种数学方法，把多阶段问题变换为一系列相互联系的单阶段问题，然后逐一加以解决。

**复杂的问题分阶段进行简化，逐步简化成简单的问题。这就是动态规划的思想。**

所以：动态规划其实是一种数学方法，是求解某类问题的一种方法，而不是一种特殊的算法，没有一个标准数学表达式或明确定义的一种规则。

我们再解决某些最有问题时，可将解决问题的过程按照一定次序分为某干个互相联系的阶段（1，2，3 ...，N），从而将一个大问题化为一系列子问题，然后逐个求解。

![多阶段决策过程](http://pic.guohuaden.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B.png)

在每个阶段都需要作出决策，从而使整个过程达到最优。**各个阶段决策的选取仅依赖当前的状态**，从而确定输出状态。当各个阶段决策确定后，就组成了一个决策序列，这个决策序列就决定了问题的最终解决方案。这种把一个问题可看作一个前后关联具有链状结构的多阶段过程就是多阶段决策过程。

**动态规划**就是将一个大问题化为一系列互相联系、同类型的子问题，然后在逐个解决子问题，当最后一个子问题得到最优解时，就是整个问题的最优解。

### **问题建模**：三个重要概念

- 最优子结构（最优子问题）
- 边界条件
- 状态转移公式

这三个部分是动态规划的前半部分，即**问题建模**

### **求解问题**

#### 1.自顶向下

##### 递归

递归的时间复杂度为O(2^n) 。已经遍历过的 会重复遍历

##### 递归+记忆搜索 （备忘录法）

时间和空间复杂度都是O(n)。

将已经遍历过的做缓存，再遍历时先判断缓存中是否存在，存在的情况下直接取出来使用。

**疑问1：**为什么说递归是自顶向下的过程呢？

这里举两个个例子，这样理解会更简单一点，

- **1、斐波那契数**

比较有名的一个就是**斐波那契数**。这里简单说一下：斐波那契数，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是

```markdown
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

从这个例子中可以看出，如果想计算F(10)的结果，就需要知道F(9)和F(8)的结果。同理，想知道F(9)的结果就需要知道F(8)和F(7)的结果...直到N == 2的时候，已知的是F(1)和F(0)的结果，才会结束得到F(10)。

- **2、台阶（楼梯）问题**

描述：一个N台阶楼梯，从下往上走，每次只能走1个或者2个台阶。求一共有多少种走法。

分析：如果N = 10，如果直接去计算有多少种走法，会很难计算。换个思路，如果只差一步就走到了第10个台阶，有几种走法？答案就会很简单：2种 （在第9台阶时向上走一台阶，在第8台阶的时候直接向上走二台阶）。假设F(9)为到达第九个台阶需要的走法，F(8)为到达第八个台阶需要的走法，那么推到就是这样**F(10) = F(9) + F(8)**

同理可以推出：**F(N) = F(N-1) + F(N-2)**   而F(1) 和F(2)的值可以直接得到:**F(1) = 1,F(2) = 2**

所以归纳为：

```
F(1) = 1
F(2) = 2
F(N) = F(N-1) + F(N-2) N > 2
```

- **问题思路总结**

所以：递归是自顶向下的过程，它的访问过程更像是一个二叉树，绘制出来的图是这样的：

![斐波那契递归过程](http://pic.guohuaden.com/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91_%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png)



**注**：

1、从递归过程图中，也可以很好的理解为什么加上缓存去记忆搜索，缓存的引入会杜绝重复访问的发生。

2、通过**F(N) = F(N-1) + F(N-1)**这样的类推过程，将一个大问题化为一系列子问题，然后逐个求解。这种将一个复杂问题逐渐简单化，也是分治算法的思想。

#### 2.自底向上

##### 迭代

迭代法是一种不断用变量的旧值递推新值的过程。

有一句话是这样说的：递归是自己调用自己，每次旨在缩小问题规模。迭代是自己执行很多次，每次旨在更接近目标。

这里还是以**斐波那契数**为例，用迭代的方式进行推导下：

已知**F(1) = 1 , F(2) = 2**  可以推出**F(3) = F(2) + F(1) = 3**,则**F(4) = F(3) + F(2) = 5**;**F(5) = F(4) + F(3) = 8**,以此类推，直到F(N) = F(N-1) + F(N-2)。这里可以很直观的看出：**迭代**是以小推大的，而且每次迭代过程中，只需要知道前两个状态就可以推出新的状态。

### 代码实现

这里简单实现下力扣上的62题：**不同路径**，为了节省时间，这里直接给出题的贴图

![不同路径问题](http://pic.guohuaden.com/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.jpg)

分析：这道题和上面台阶的题很像,不同的是变量有一个换成了两个，但原理是一样的。到达**Finish**只有两种走法：向右或者向下，所以F(m,n) = F(m-1,n) + F(m,n-1)。再找边界条件：当m == 1 或者 n == 1的时候，看例子中的图可以知道，都只有一条路线。所以**F(1,n) = 1,F(m,1) = 1**;当m== n == 2的时候，也是不用计算就可以知道的**F(2,2) = 2**。现在边界条件和推导公式都找到了，就可以直接去做代码的实现。

#### 递归实现

```javascript
function dp_function(m ,n) {
    if (m == 1 || n == 1){
        return 1;
    }

    if (m == 2 && n == 2){
        return 2;
    }
     
    return dp_function(m-1,n) + dp_function(m,n-1);
}
console.log(dp_function(3,3));
```

#### 递归+记忆搜索

```javascript
function dp_function_canche(m ,n, cacheMap) {
    if (m == 1 || n == 1){
        return 1;
    }

    if (m == 2 && n == 2){
        return 2;
    }
    var key = m + ',' + n;
    if (cacheMap.has(key)) {
        return cacheMap.get(key);
    }
    var value = dp_function_canche(m-1,n,cacheMap) + dp_function_canche(m,n-1,cacheMap);
    cacheMap.set(key,value);
    return value;
}

var cacheMap = new Map();
console.log(dp_function_canche(3,3,cacheMap));
```

#### 迭代实现--一维数组

```javascript
function dp_fs_two(m,n){
    if (m <= 0 || n <= 0){
        return 0;
    }
    if (m == 1 || n == 1){
        return 1;
    }
    if(m == 2 && n == 2){
        return 2;
    }
		//初始化
    var dp = [];
    for(var i = 0; i < m; i++){
        for(var j = 0; j < n; j++){
            if (i == 0 || j == 0){
                dp[i+m*j] = 1;//这里是给初始化做的补充，m == 1 或者 n == 1 时只有一种路径(数组中的下标对应的是0、0)
            }else{
                dp[i+m*j] = 0;
            }
            
        }
    }
  	//迭代
    for(var i = 1; i < m; i++){
        for(var j = 1; j < n; j++){
            dp[i+m*j] = dp[(i-1)+m*j] + dp[i+m*(j-1)];
        }
    }
    return dp[(i-1)+m*(j-1)];//传入的m、n 在数组中的下标位置为：m-1 、n-1
}
console.log(dp_fs_two(2,3));
```

#### 迭代实现--二维数组

```javascript
function dp_fs(m,n){
    //边界条件
    if (m <= 0 || n <= 0){
        return 0;
    }
    if (m == 1 || n == 1){
        return 1;
    }
    if(m == 2 && n == 2){
        return 2;
    }
    //初始化
    var dp = [];
    for(var i = 0; i < m; i++){
        dp[i] = [];
        for(var j = 0; j < n; j++){
            dp[i][j] = 0;
        }
    }
    //这里是给初始化做的补充，m == 1 或者 n == 1 时只有一种路径
    for(var i = 0; i < m; i++){
        dp[i][0] = 1;
    }
    for(var j = 0; j < n; j++){
        dp[0][j] = 1;
    }
    //迭代
    for(var i = 1; i < m; i++){
        for(var j = 1; j < n; j++){
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1]; //传入的m、n 在数组中的下标位置为：m-1 、n-1
}
console.log(dp_fs(7,3));
```

















 

